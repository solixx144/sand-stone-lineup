<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin ‚Äî Sandstone Editor</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* admin-specific small overrides */
    .admin-ui{position:fixed;right:12px;top:64px;width:320px;background:rgba(0,0,0,0.8);padding:12px;border-radius:8px;z-index:1500}
    .admin-ui label{display:block;margin-top:8px;font-size:13px}
    .admin-ui input[type="text"], .admin-ui select{width:100%;padding:6px;margin-top:6px;border-radius:6px;border:1px solid #222;background:#111;color:#fff}
    .admin-ui button{margin-top:8px;padding:8px 10px;border-radius:6px;background:#1b6;padding:0 8px;border:none;cursor:pointer}
    .grid-overlay{
      position:absolute;inset:0;pointer-events:none;z-index:115;
      background-image:
        linear-gradient(to right, rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: var(--grid-size) var(--grid-size);
      mix-blend-mode: overlay;
    }
    .draggable-dot{position:absolute;width:20px;height:20px;border-radius:50%;transform:translate(-50%,-50%);cursor:grab;z-index:130}
    .draggable-dot.dragging{cursor:grabbing;opacity:.95;box-shadow:0 12px 30px rgba(0,0,0,0.6)}
    /* small note */
    .hint{font-size:12px;opacity:.8;margin-top:6px}
  </style>
</head>
<body class="theme-dark">

  <header class="top-bar">
    <div>ADMIN ‚Äî Sandstone Editor</div>
    <div><a href="./index.html" target="_blank">A√ßƒ±k siteyi g√∂r</a></div>
  </header>

  <div class="ad-wall left"></div>
  <div class="ad-wall right"></div>

  <main class="map-wrapper" id="adminMapWrapper">
    <img id="map" src="map.png" alt="map" />
    <div id="pointsLayer"></div>
    <div id="gridOverlay" class="grid-overlay" style="display:block"></div>
  </main>

  <aside class="admin-ui">
    <label>T√ºr</label>
    <select id="typeSelect">
      <option value="smoke">Smoke</option>
      <option value="flash">Flash</option>
      <option value="molly">Molly</option>
      <option value="grenade">Grenade</option>
    </select>

    <label>Video URL (YouTube embed veya mp4)</label>
    <input id="videoInput" type="text" placeholder="https://www.youtube.com/embed/..." />

    <button id="addPointBtn">‚ûï Nokta Ekle</button>
    <button id="toggleGridBtn">üìê Grid Gizle</button>
    <button id="saveBtn">üíæ Kaydet (Ana siteye yansƒ±r)</button>
    <button id="exportBtn">‚¨á Export JSON</button>
    <button id="importBtn">‚¨Ü Import JSON</button>
    <input type="file" id="importFile" style="display:none" accept=".json" />

    <div class="hint">Snap: 25px. Mobilde s√ºr√ºkleme kapalƒ±.</div>
  </aside>

<script>
/* Admin panel script */
const STORAGE_KEY = 'st_points_v1';
const gridSize = 25; // C se√ßimi
const pointsLayer = document.getElementById('pointsLayer');
const mapImg = document.getElementById('map');
const addPointBtn = document.getElementById('addPointBtn');
const saveBtn = document.getElementById('saveBtn');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');
const toggleGridBtn = document.getElementById('toggleGridBtn');
const gridOverlay = document.getElementById('gridOverlay');
const typeSelect = document.getElementById('typeSelect');
const videoInput = document.getElementById('videoInput');

let dragState = { dragging: false, el: null, offsetX:0, offsetY:0 };
let isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);

// load existing points
function getStored(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); }catch(e){ return [] } }
function setStored(list){ localStorage.setItem(STORAGE_KEY, JSON.stringify(list)); /* triggers storage event for main site */ }

// convert pixel to percent relative to map wrapper
function pxToPercent(xPx, yPx){
  const rect = mapImg.getBoundingClientRect();
  const left = xPx - rect.left;
  const top = yPx - rect.top;
  const cx = Math.max(0, Math.min(left, rect.width));
  const cy = Math.max(0, Math.min(top, rect.height));
  return { left: (cx / rect.width * 100).toFixed(4) + '%', top: (cy / rect.height * 100).toFixed(4) + '%' };
}

// convert percent to pixel (for placing draggable DOM)
function percentToPx(leftPct, topPct){
  const rect = mapImg.getBoundingClientRect();
  const lx = parseFloat(leftPct) / 100 * rect.width + rect.left;
  const ty = parseFloat(topPct) / 100 * rect.height + rect.top;
  return { x: lx, y: ty };
}

// snap a pixel position to grid relative to map rect
function snapToGrid(clientX, clientY){
  const rect = mapImg.getBoundingClientRect();
  const relX = clientX - rect.left;
  const relY = clientY - rect.top;
  const snappedX = Math.round(relX / gridSize) * gridSize;
  const snappedY = Math.round(relY / gridSize) * gridSize;
  // clamp
  const clampedX = Math.max(0, Math.min(snappedX, rect.width));
  const clampedY = Math.max(0, Math.min(snappedY, rect.height));
  return { x: rect.left + clampedX, y: rect.top + clampedY };
}

// render all stored points as draggable dots
function renderStored(){
  pointsLayer.innerHTML = '';
  const list = getStored();
  list.forEach((pt, idx) => {
    const el = document.createElement('div');
    el.className = 'draggable-dot ' + pt.type;
    el.style.left = pt.left;
    el.style.top = pt.top;
    el.dataset.index = idx;
    el.dataset.video = pt.video || '';
    el.title = pt.type + (pt.video ? ' (video)' : '');
    // allow click to edit
    el.addEventListener('dblclick', (e)=>{
      e.stopPropagation();
      // load into controls
      typeSelect.value = pt.type;
      videoInput.value = pt.video || '';
      // mark active for editing deletion
      document.querySelectorAll('.draggable-dot').forEach(x=>x.style.outline='');
      el.style.outline = '2px solid #ffd';
      el.dataset.edit = '1';
    });
    // drag handlers
    if(!isMobile){
      el.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        dragState.dragging = true;
        dragState.el = el;
        // compute pointer offset so cursor remains center-ish
        const rect = el.getBoundingClientRect();
        dragState.offsetX = e.clientX - rect.left - rect.width/2;
        dragState.offsetY = e.clientY - rect.top - rect.height/2;
        el.classList.add('dragging');
      });
    }
    // right-click to delete
    el.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault();
      if(confirm('Bu noktayƒ± sil?')){
        const arr = getStored();
        arr.splice(idx,1);
        setStored(arr);
        renderStored();
      }
    });

    pointsLayer.appendChild(el);
  });
}

// on mousemove for dragging
document.addEventListener('mousemove', (e)=>{
  if(!dragState.dragging || !dragState.el) return;
  const snapped = snapToGrid(e.clientX - dragState.offsetX, e.clientY - dragState.offsetY);
  const pct = pxToPercent(snapped.x, snapped.y);
  dragState.el.style.left = pct.left;
  dragState.el.style.top = pct.top;
});

// stop drag and save final pos
document.addEventListener('mouseup', ()=>{
  if(dragState.dragging && dragState.el){
    dragState.el.classList.remove('dragging');
    // save new positions back to storage
    const idx = parseInt(dragState.el.dataset.index,10);
    if(!isNaN(idx)){
      const arr = getStored();
      arr[idx].left = dragState.el.style.left;
      arr[idx].top = dragState.el.style.top;
      arr[idx].video = dragState.el.dataset.video || arr[idx].video || '';
      setStored(arr);
      renderStored();
    }
  }
  dragState.dragging = false;
  dragState.el = null;
});

// add new point (centered on map)
addPointBtn.addEventListener('click', ()=>{
  // default at center
  const rect = mapImg.getBoundingClientRect();
  const centerX = rect.left + rect.width/2;
  const centerY = rect.top + rect.height/2;
  const snapped = snapToGrid(centerX, centerY);
  const pct = pxToPercent(snapped.x, snapped.y);
  const arr = getStored();
  arr.push({ type: typeSelect.value, left: pct.left, top: pct.top, video: videoInput.value || '' });
  setStored(arr);
  renderStored();
});

// save button (explicit)
saveBtn.addEventListener('click', ()=>{
  // If user has selected a highlighted dot (edit), update it
  const editEl = document.querySelector('.draggable-dot[data-edit="1"]');
  if(editEl){
    const idx = parseInt(editEl.dataset.index,10);
    const arr = getStored();
    arr[idx].type = typeSelect.value;
    arr[idx].video = videoInput.value || '';
    setStored(arr);
    editEl.dataset.edit = '0';
    editEl.style.outline = '';
    renderStored();
    alert('Se√ßili nokta g√ºncellendi ve kaydedildi.');
    return;
  }
  alert('Deƒüi≈üiklikler kaydedildi.');
});

// export JSON
exportBtn.addEventListener('click', ()=>{
  const arr = getStored();
  const blob = new Blob([JSON.stringify(arr,null,2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'sandstone_points.json';
  a.click(); URL.revokeObjectURL(url);
});

// import JSON
importBtn.addEventListener('click', ()=> importFile.click());
importFile.addEventListener('change', (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    try{
      const parsed = JSON.parse(e.target.result);
      if(Array.isArray(parsed)){
        setStored(parsed);
        renderStored();
        alert('Import ba≈üarƒ±lƒ±.');
      } else alert('Ge√ßersiz JSON formatƒ±.');
    }catch(err){ alert('JSON okunamadƒ±.'); }
  };
  reader.readAsText(f);
});

// toggle grid visibility
toggleGridBtn.addEventListener('click', ()=>{
  const visible = gridOverlay.style.display !== 'none';
  gridOverlay.style.display = visible ? 'none' : 'block';
  toggleGridBtn.textContent = visible ? 'üìê Grid G√∂ster' : 'üìê Grid Gizle';
});

// initialize: render and make grid size correct
function initAdmin(){
  // set CSS custom property for grid size
  document.documentElement.style.setProperty('--grid-size', gridSize + 'px');
  renderStored();
}
initAdmin();

// click on map to add at clicked snapped location
document.getElementById('adminMapWrapper').addEventListener('click', (e)=>{
  if(e.target.id === 'map' || e.target.id === 'gridOverlay'){
    // ignore clicks on UI elements
    const snapped = snapToGrid(e.clientX, e.clientY);
    const pct = pxToPercent(snapped.x, snapped.y);
    const arr = getStored();
    arr.push({ type: typeSelect.value, left: pct.left, top: pct.top, video: videoInput.value || '' });
    setStored(arr);
    renderStored();
  }
});

</script>
</body>
</html>
